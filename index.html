<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Reto's personal Game</title>
  <link rel="manifest" href="./manifest.webmanifest" />
  <style>
    /* Layout */
    body{
      font-family:system-ui,Arial;
      max-width:980px;
      margin:22px auto;
      padding:0 14px;
      background:#081a3a;
      color:#f4f7ff
    }
    .muted{opacity:.78}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .split{justify-content:space-between}
    .grow{flex:1;min-width:220px}

    .card{
      border:1px solid rgba(255,255,255,.10);
      border-radius:14px;
      padding:14px;
      margin:12px 0;
      background:rgba(255,255,255,.06);
      box-shadow:0 10px 26px rgba(0,0,0,.25);
      backdrop-filter: blur(6px);
    }
    .stat{
      border:1px dashed rgba(255,255,255,.18);
      border-radius:12px;
      padding:10px 12px;
      min-width:160px
    }
    .pill{
      display:inline-block;
      border:1px solid rgba(255,255,255,.16);
      border-radius:999px;
      padding:4px 10px;
      margin:4px 6px 0 0;
      font-size:13px;
      background:rgba(0,0,0,.10)
    }
    .q{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      border:1px solid rgba(255,255,255,.10);
      border-radius:12px;
      padding:10px;
      margin:8px 0;
      background:rgba(0,0,0,.10)
    }
    .q small{opacity:.75}
    .danger{border-color:#ff4b4b;color:#ffb8b8}
    button,input,select,textarea{padding:10px;font-size:14px}
    textarea{min-height:80px;resize:vertical;width:100%}
    button{cursor:pointer}
    .dial{
      width:84px;height:84px;border-radius:50%;
      border:2px solid rgba(255,255,255,.35);
      display:grid;place-items:center
    }
    .dial span{font-weight:700}

    .q .qtitle{font-weight:700}
    .q .qmeta{opacity:.8;font-size:13px;margin-top:4px}
    .q .qdesc{opacity:.8;margin-top:2px}
    .hidden{display:none !important}

    /* --- Theme variables --- */
    :root{
      --bg:#081a3a;
      --fg:#f4f7ff;
      --card:rgba(255,255,255,.06);
      --border:rgba(255,255,255,.12);
      --accent:#dbe7ff;
      --accent2:#62d28e;
      --shadow:rgba(0,0,0,.25);
    }

    body{background:var(--bg);color:var(--fg)}
    body.retro{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}

    /* Optional: Xmas accents (background bleibt dunkelblau) */
    body.xmas{--accent:#ffccd6;--accent2:#62d28e}
    body.classic{--accent:#dbe7ff;--accent2:#a6c8ff}

    /* Pixel UI */
    body.pixel button,
    body.pixel input,
    body.pixel select{
      border:2px solid rgba(255,255,255,.35);
      background:rgba(0,0,0,.10);
      color:var(--fg);
      border-radius:10px;
      box-shadow: 0 4px 0 rgba(0,0,0,.35);
      transform: translateY(0);
    }
    body.pixel textarea{
      border:2px solid rgba(255,255,255,.25);
      background:rgba(0,0,0,.10);
      color:var(--fg);
      border-radius:12px;
    }
    body.pixel button:active{
      transform: translateY(2px);
      box-shadow: 0 2px 0 rgba(0,0,0,.35);
    }
    body.pixel .card{
      border-width:2px;
      border-radius:16px;
      box-shadow: 0 10px 0 rgba(0,0,0,.10);
    }
    body.pixel .pill{
      border-width:2px;
      border-radius:999px;
      box-shadow: 0 3px 0 rgba(0,0,0,.18);
    }
    .btn-accent{
      border:2px solid var(--accent2) !important;
      box-shadow: 0 4px 0 rgba(0,0,0,.35) !important;
    }
    .kbd{
      border:1px solid rgba(255,255,255,.18);
      border-bottom-width:3px;
      border-radius:8px;
      padding:2px 8px;
      font-size:12px;
      opacity:.92;
      background:rgba(0,0,0,.12)
    }

    /* Tabs */
    .tabs{display:flex;gap:10px;flex-wrap:wrap}
    .tabs button{padding:10px 12px}
    .tabs button.active{background:rgba(255,255,255,.16);color:var(--fg)}

    /* Modal */
    .modalBack{
      position:fixed;inset:0;background:rgba(0,0,0,.65);
      display:flex;align-items:center;justify-content:center;z-index:9999
    }
    .modal{
      width:min(760px,92vw);
      background:rgba(8,26,58,.96);
      border:1px solid rgba(255,255,255,.14);
      border-radius:16px;
      padding:16px 16px 14px;
      box-shadow:0 20px 60px rgba(0,0,0,.45)
    }
    .titleRow{display:flex;justify-content:space-between;gap:10px;align-items:flex-start}
    .spark{color:var(--accent2);font-weight:800}
    pre.storyBox{
      white-space:pre-wrap;
      border:2px solid rgba(255,255,255,.16);
      border-radius:12px;
      padding:12px;
      background:rgba(0,0,0,.18);
      line-height:1.5;
      margin:10px 0 0 0;
    }

    /* =========================
       SNAKE: gr√∂√üer + mobile
       ========================= */
    #snakeCanvas{
      border:2px solid rgba(255,255,255,.35);
      border-radius:10px;
      image-rendering:pixelated;

      width: min(96vw, 520px);
      height: auto;
      max-width: 520px;

      touch-action: none; /* wichtig f√ºr Swipe */
      background:#fff;
    }
    .snakeHUD{display:flex;gap:10px;flex-wrap:wrap;align-items:center}

    /* Mobile D-Pad */
    .dpad{
      display:grid;
      grid-template-columns: 52px 52px 52px;
      grid-template-rows: 52px 52px 52px;
      gap:8px;
      justify-content:start;
      align-items:center;
      margin-top:12px;
    }
    .dpad button{
      width:52px;height:52px;
      display:grid;place-items:center;
      font-size:18px;
    }
    .dpad .empty{visibility:hidden}

    /* Snow overlay (pure CSS, light) */
    body.xmas::before{
      content:"";
      position:fixed;inset:-200px 0 0 0;
      pointer-events:none;
      background-image:
        radial-gradient(2px 2px at 10% 20%, rgba(255,255,255,.95) 50%, transparent 52%),
        radial-gradient(2px 2px at 30% 60%, rgba(255,255,255,.85) 50%, transparent 52%),
        radial-gradient(1.5px 1.5px at 70% 35%, rgba(255,255,255,.9) 50%, transparent 52%),
        radial-gradient(1.5px 1.5px at 85% 70%, rgba(255,255,255,.8) 50%, transparent 52%),
        radial-gradient(1px 1px at 55% 10%, rgba(255,255,255,.8) 50%, transparent 52%),
        radial-gradient(1px 1px at 15% 85%, rgba(255,255,255,.75) 50%, transparent 52%);
      background-size: 420px 420px, 520px 520px, 460px 460px, 560px 560px, 380px 380px, 600px 600px;
      animation:snowFall 10s linear infinite;
      opacity:.45;
    }
    @keyframes snowFall{
      from{transform:translateY(-120px)}
      to{transform:translateY(220px)}
    }

    /* Gift card print */
    .giftPrint{
      border:2px dashed rgba(255,255,255,.18);
      border-radius:16px;
      padding:14px;
      display:grid;
      grid-template-columns: 1fr 220px;
      gap:14px;
      align-items:center;
      background:#fff;
      color:#111;
    }
    .giftPrint h2{margin:0}
    .giftPrint .meta{opacity:.85}
    .giftPrint canvas{background:#fff;border:1px solid #eee;border-radius:10px}
    @media print{
      body{max-width:none;margin:0;padding:0;background:#fff;color:#111}
      .noPrint{display:none !important}
      #tab-card{display:block !important}
      #printArea{display:block !important}
      .card{box-shadow:none;background:#fff;color:#111;border-color:#ddd}
    }
  </style>
</head>

<body class="pixel xmas">
  <h1 id="appTitle">Reto's personal Game</h1>
  <div class="muted" id="appSubtitle">Deine Quests werden lokal auf deinem Ger√§t gespeichert (kein Account, kein Server).</div>

  <!-- Update Bar -->
  <div id="updateBar" class="card noPrint hidden" style="border-color:var(--accent2)">
    <div class="row split">
      <div>
        <b>Update verf√ºgbar</b>
        <div class="muted">Neu laden, um die neueste Version zu verwenden.</div>
      </div>
      <div class="row">
        <button id="reloadNow" class="btn-accent" type="button">Neu laden</button>
        <button id="reloadLater" type="button">Sp√§ter</button>
      </div>
    </div>
  </div>

  <div class="card noPrint">
    <div class="row split">
      <div class="tabs" id="tabs">
        <button data-tab="quests" class="active">üó°Ô∏è Quests</button>
        <button data-tab="story">üìú Story</button>
        <button data-tab="game">üêç Snake</button>
        <button data-tab="card">üéÅ QR & Karte</button>
      </div>
      <div class="row">
        <span class="kbd" title="Funktioniert offline, sobald einmal ge√∂ffnet">offline</span>
      </div>
    </div>
  </div>

  <!-- Geschenk-Intro Modal -->
  <div id="giftModalBack" class="modalBack hidden" role="dialog" aria-modal="true">
    <div class="modal">
      <div class="titleRow">
        <div>
          <div class="muted">Reto's personal Game</div>
          <h2 style="margin:.25rem 0 0 0" id="giftModalTitle">üéÑ Quest-Start</h2>
        </div>
        <button id="giftClose" title="Schlie√üen" type="button">‚úï</button>
      </div>

      <div id="giftModalText" style="margin-top:10px;line-height:1.5"></div>
      <pre class="storyBox" id="giftModalStory"></pre>

      <div class="row" style="margin-top:14px">
        <button id="giftStart" class="btn-accent" type="button">Los geht‚Äôs</button>
        <div class="muted">Ziel: jeden Tag kleine Quests ‚Üí XP ‚Üí Level ‚Üí Achievements.</div>
      </div>
    </div>
  </div>

  <!-- TAB: QUESTS -->
  <div id="tab-quests">
    <div class="card">
      <div class="row">
        <div class="stat"><div class="muted">Level</div><div style="font-size:28px" id="level">1</div></div>
        <div class="stat"><div class="muted">XP</div><div style="font-size:28px"><span id="xp">0</span> / <span id="xpNext">100</span></div></div>
        <div class="stat"><div class="muted">Coins</div><div style="font-size:28px" id="coins">0</div></div>
        <div class="stat"><div class="muted">Streak (Tage)</div><div style="font-size:28px" id="streak">0</div></div>
        <div class="dial" title="Fokus-Timer (Mini)"><span id="timerTxt">00:00</span></div>
        <button id="timerBtn" type="button">‚ñ∂ Fokus 15:00</button>
      </div>
    </div>

    <div class="card">
      <div class="row">
        <h3 style="margin:0">Quests</h3>
        <button id="newDaily" type="button">‚Üª Daily Quests</button>
        <button id="newWeekly" type="button">‚Üª Weekly Quests</button>
        <button id="reset" class="danger" type="button">Reset</button>
      </div>
      <div class="muted" style="margin-top:8px">Tipp: F√ºr den Retro-Daily kannst du ‚ÄûDaily: Snake-Run‚Äú in den Geschenk-Einstellungen aktivieren.</div>
      <div id="questList"></div>
    </div>

    <div class="card">
      <div class="row split">
        <h3 style="margin:0">Eigene Quests (anpassbar)</h3>
        <div class="row">
          <button id="exportBtn" type="button">Export</button>
          <button id="importBtn" type="button">Import</button>
        </div>
      </div>

      <div class="row" style="margin-top:10px">
        <input id="cqTitle" class="grow" placeholder="Titel (z.B. 10 Min lesen)">
        <input id="cqDesc" class="grow" placeholder="Beschreibung (optional)">
      </div>

      <div class="row" style="margin-top:10px">
        <input id="cqTag" placeholder="Tag (z.B. Lernen)" style="width:160px">
        <select id="cqType" style="width:140px">
          <option value="daily">Daily</option>
          <option value="weekly">Weekly</option>
          <option value="boss">Boss</option>
        </select>
        <input id="cqXP" type="number" min="0" value="30" style="width:120px" title="XP">
        <input id="cqCoins" type="number" min="0" value="5" style="width:120px" title="Coins">
        <button id="cqAdd" type="button">Ôºã Hinzuf√ºgen</button>
        <button id="cqCancel" class="danger" style="display:none" type="button">Abbrechen</button>
      </div>

      <div class="muted" style="margin-top:8px">
        Deine Quests werden beim Generieren automatisch mit den Standard-Quests gemischt (und lokal gespeichert).
      </div>

      <div id="customQuestList"></div>
    </div>

    <div class="card">
      <h3 style="margin-top:0">Achievements</h3>
      <div id="ach"></div>
    </div>

    <div class="card">
      <h3 style="margin-top:0">Log</h3>
      <ul id="log"></ul>
    </div>
  </div>

  <!-- TAB: STORY -->
  <div id="tab-story" class="hidden">
    <div class="card">
      <div class="row split">
        <h3 style="margin:0">üìú Quest Story</h3>
        <button id="storyShow" class="btn-accent" type="button">Intro anzeigen</button>
      </div>
      <div class="muted" style="margin-top:8px">RPG-Intro-Text. Du kannst ihn sp√§ter komplett personalisieren.</div>
      <pre class="storyBox" id="storyPreview"></pre>
    </div>

    <div class="card">
      <h3 style="margin-top:0">Story bearbeiten</h3>
      <textarea id="giftStory" placeholder="Du bist der Held... Mission: 2026 ..."></textarea>
      <div class="row" style="margin-top:10px">
        <button id="storySave" class="btn-accent" type="button">Speichern</button>
        <button id="storyReset" type="button">Zur√ºcksetzen</button>
      </div>
      <div class="muted" style="margin-top:8px">Alles wird lokal im Browser gespeichert. Kein Account n√∂tig.</div>
    </div>
  </div>

  <!-- TAB: GAME (SNAKE) -->
  <div id="tab-game" class="hidden">
    <div class="card">
      <div class="row split">
        <h3 style="margin:0">üêç Snake (Retro)</h3>
        <div class="row">
          <span class="pill" id="snakeHighPill">Highscore: 0</span>
          <span class="pill" id="snakeDailyPill">Daily: bereit</span>
        </div>
      </div>

      <div class="snakeHUD" style="margin-top:10px">
        <button id="snakeStart" class="btn-accent" type="button">‚ñ∂ Start</button>
        <button id="snakePause" type="button">‚è∏ Pause</button>
        <button id="snakeReset" type="button">‚Ü∫ Reset Run</button>

        <label class="row" style="gap:6px">
          <span class="muted">Speed</span>
          <select id="snakeSpeed">
            <option value="3">Langsam</option>
            <option value="5" selected>Normal</option>
            <option value="7">Schnell</option>
            <option value="9">Ultra</option>
          </select>
        </label>

        <label class="row" style="gap:6px">
          <input id="snakeWrapToggle" type="checkbox">
          <span>Wrap-around (keine W√§nde)</span>
        </label>

        <label class="row" style="gap:6px">
          <input id="snakeRampToggle" type="checkbox" checked>
          <span>Speed steigt mit Score</span>
        </label>

        <label class="row" style="gap:6px">
          <input id="snakeDailyQuestToggle" type="checkbox" checked>
          <span>Daily: 1 Run pro Tag (Quest + Bonus)</span>
        </label>
      </div>

      <div class="row" style="margin-top:10px;gap:14px">
        <canvas id="snakeCanvas" width="320" height="320" aria-label="Snake Spiel"></canvas>
        <div class="grow" style="min-width:260px">
          <div class="pill" id="snakeScorePill">Score: 0</div>
          <div style="margin-top:10px" class="muted">
            Steuerung: <span class="kbd">‚Üë</span> <span class="kbd">‚Üì</span> <span class="kbd">‚Üê</span> <span class="kbd">‚Üí</span> oder <span class="kbd">WASD</span><br/>
            Daily-Quest: mind. <b>5 Punkte</b> ‚Üí Belohnung (1√ó pro Tag).<br/>
            Highscore-Bonus: wenn du deinen Highscore schl√§gst.
          </div>

          <div class="dpad" aria-label="Snake Steuerkreuz (Touch)">
            <span class="empty"></span>
            <button id="btnUp" type="button">‚Üë</button>
            <span class="empty"></span>

            <button id="btnLeft" type="button">‚Üê</button>
            <button id="btnPause" type="button">‚è∏</button>
            <button id="btnRight" type="button">‚Üí</button>

            <span class="empty"></span>
            <button id="btnDown" type="button">‚Üì</button>
            <span class="empty"></span>
          </div>

          <div class="muted" style="margin-top:8px">
            Tipp (Handy): Wischen oder D-Pad benutzen. Tap auf ‚è∏ pausiert.
          </div>

          <div style="margin-top:12px">
            <button id="snakeClaim" class="btn-accent" type="button">Daily-Bonus pr√ºfen</button>
          </div>
          <div class="muted" style="margin-top:8px" id="snakeMsg"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- TAB: CARD / QR -->
  <div id="tab-card" class="hidden">
    <div class="card">
      <div class="row split">
        <h3 style="margin:0">üéÅ Geschenkmodus</h3>
        <div class="row">
          <button id="giftPreview" type="button">Intro anzeigen</button>
        </div>
      </div>

      <div class="row" style="margin-top:10px">
        <input id="giftName" class="grow" placeholder="Name (z.B. Reto)">
        <select id="giftTheme" style="width:220px">
          <option value="xmas">Weihnachts-Akzente</option>
          <option value="retro">Retro (Monospace)</option>
          <option value="classic">Classic</option>
        </select>
      </div>

      <div style="margin-top:10px">
        <textarea id="giftMsg" placeholder="Kurze Nachricht (z.B. Frohe Weihnachten! üéÑ)"></textarea>
      </div>

      <div class="row" style="margin-top:10px">
        <label class="row" style="gap:6px">
          <input id="giftPixel" type="checkbox" checked>
          <span>Pixel-Look aktiv</span>
        </label>
        <label class="row" style="gap:6px">
          <input id="giftSnakeDaily" type="checkbox" checked>
          <span>Daily: Snake-Run automatisch zu Dailies hinzuf√ºgen</span>
        </label>
      </div>

      <div class="row" style="margin-top:10px">
        <button id="giftSave" class="btn-accent" type="button">Speichern</button>
        <div class="muted">Du kannst sp√§ter alles personalisieren ‚Äì alles bleibt lokal gespeichert.</div>
      </div>
    </div>

    <div class="card">
      <div class="row split">
        <h3 style="margin:0">üìé QR-Code & Karte</h3>
        <button id="printBtn" class="btn-accent" type="button">üñ®Ô∏è Drucken</button>
      </div>
      <div class="muted" style="margin-top:8px">
        Gib hier deinen Link zur App ein ‚Üí QR-Code scannen ‚Üí fertig.
      </div>

      <div class="row" style="margin-top:10px">
        <input id="qrUrl" class="grow" placeholder="https://... (Link zur App)">
        <button id="qrGen" type="button">QR erzeugen</button>
      </div>

      <div id="printArea" style="margin-top:12px">
        <div class="giftPrint">
          <div>
            <div class="muted">Reto's personal Game ‚Äî Geschenk</div>
            <h2 id="cardTitle">F√ºr ...</h2>
            <div class="meta" id="cardMsg" style="margin-top:8px"></div>
            <div class="meta" style="margin-top:10px">Scanne den QR-Code oder √∂ffne den Link.</div>
            <div class="meta" id="cardUrl" style="margin-top:6px"></div>
          </div>
          <div style="display:grid;justify-items:end;gap:8px">
            <canvas id="qrCanvas" width="200" height="200"></canvas>
            <div class="muted" style="font-size:12px">QR-Code (offline erzeugt)</div>
          </div>
        </div>
      </div>
    </div>

    <div class="card">
      <h3 style="margin-top:0">üéÑ Special Weihnachts-Achievements</h3>
      <div class="muted">Bonus-Achievements f√ºr Weihnachts-Quests & Snake.</div>
      <div style="margin-top:10px" id="xmasAchHint"></div>
    </div>
  </div>

<script>
  const KEY="retos_personal_game_v1";
  const el = (id)=>document.getElementById(id);

  /* =========================
     Service Worker: Update-Flow
     ========================= */
  (function setupServiceWorker(){
    if(!("serviceWorker" in navigator)) return;

    const updateBar = document.getElementById("updateBar");
    const reloadNow = document.getElementById("reloadNow");
    const reloadLater = document.getElementById("reloadLater");

    let newWorker = null;

    function showUpdate(){ updateBar && updateBar.classList.remove("hidden"); }
    function hideUpdate(){ updateBar && updateBar.classList.add("hidden"); }

    navigator.serviceWorker.register("./sw.js").then((reg) => {
      reg.addEventListener("updatefound", () => {
        const installing = reg.installing;
        if(!installing) return;

        installing.addEventListener("statechange", () => {
          if(installing.state === "installed" && navigator.serviceWorker.controller){
            newWorker = installing;
            showUpdate();
          }
        });
      });

      if(reg.update) reg.update().catch(()=>{});
    }).catch(()=>{});

    reloadNow && reloadNow.addEventListener("click", () => {
      hideUpdate();
      if(newWorker){
        newWorker.postMessage({type:"SKIP_WAITING"});
      } else {
        location.reload();
      }
    });
    reloadLater && reloadLater.addEventListener("click", hideUpdate);

    navigator.serviceWorker.addEventListener("controllerchange", () => {
      location.reload();
    });
  })();

  // --- Helpers ---
  function toInt(v, fallback=0){ const n=parseInt(v,10); return Number.isFinite(n)?n:fallback; }
  function todayISO(){ const d=new Date(); d.setHours(0,0,0,0); return d.toISOString().slice(0,10); }
  function yesterdayISO(){ const d=new Date(); d.setHours(0,0,0,0); d.setDate(d.getDate()-1); return d.toISOString().slice(0,10); }
  function xpForNext(level){ return 100 + (level-1)*60; }

  // --- Achievements ---
  const ACH_LABELS = {
    firstQuest: "Erste Quest",
    quest10: "Der Grind (10 Quests)",
    boss1: "Boss besiegt (1 Bosskampf)",
    streak3: "Streak x3",
    lvl5: "Level 5",
    focus1: "Fokus (1 Timer abgeschlossen)",

    xmasMulled: "üéÑ Gl√ºhwein-Quest",
    xmasRaid: "üéÑ Family Raid",
    winterGrind: "üéÑ Wintergrind (5 Xmas-Quests)",

    snake5: "üêç Snake: 5 Punkte",
    snake20: "üêç Snake: 20 Punkte",
    snakeHS: "üêç Highscore geknackt"
  };

  function defaultGiftMessage(){
    return `Frohe Weihnachten, Reto! üéÑ
Nach Weihnachten folgt bald ein neues Jahr mit neuen Abenteuern und Missionen. Dazu m√∂chte ich dir dein eigenes Lebens-Game schenken, in dem du dir selbst Ziele setzt und sie Schritt f√ºr Schritt erreichen kannst.
Hier ist dein pers√∂nlicher Game-Modus ‚Äì jeden Tag kleine Missionen, XP sammeln und leveln.`;
  }

  function defaultStoryTemplate(name){
    const n = name ? name : "Held";
    return `Du bist ${n}.

Mission: 2026.

Dein Auftrag:
- Jeden Tag 1‚Äì3 kleine Quests erledigen.
- XP sammeln, Coins verdienen, leveln.
- Und ganz nebenbei: das echte Leben wie ein Game spielen.

Regel #1: klein & konstant schl√§gt perfekt.
Regel #2: Wenn‚Äôs stressig wird: Fokus-Timer + 1 Mini-Quest.

Viel Erfolg! üéÑ`;
  }

  function defaultState(){
    return {
      level:1, xp:0, coins:0, streak:0, lastDay:null,
      quests:[],
      customQuests:[],
      log:[], ach:{}, stats:{done:0,boss:0,focusDone:0,xmasDone:0},
      ui:{tab:"quests"},
      gift:{
        recipientName:"Reto",
        message: defaultGiftMessage(),
        story:"",
        theme:"xmas",
        pixel:true,
        snakeDailyQuest:true,
        introSeen:false,
        shareUrl:""
      },
      game:{
        snakeHighScore:0,
        snakeLastDailyDone:null,
        snakeDailyEnabled:true,
        snakePendingDaily:false,
        snakeWrap:false,
        snakeRamp:true
      }
    };
  }

  function normalizeState(s){
    const d = defaultState();
    if(!s || typeof s!=="object") s = d;

    if(!s.stats) s.stats = {...d.stats};
    if(!s.ach) s.ach = {};
    if(!Array.isArray(s.customQuests)) s.customQuests = [];
    if(!Array.isArray(s.quests)) s.quests = [];
    if(!Array.isArray(s.log)) s.log = [];
    if(!s.ui) s.ui = {tab:"quests"};
    if(typeof s.ui.tab!=="string") s.ui.tab="quests";

    if(!s.gift || typeof s.gift!=="object") s.gift = {...d.gift};
    s.gift.recipientName = String(s.gift.recipientName||"Reto");
    s.gift.message = String(s.gift.message||d.gift.message);
    s.gift.story = String(s.gift.story||"");
    if(!["xmas","retro","classic"].includes(s.gift.theme)) s.gift.theme="xmas";
    s.gift.pixel = (s.gift.pixel!==false);
    s.gift.snakeDailyQuest = (s.gift.snakeDailyQuest!==false);
    if(typeof s.gift.introSeen!=="boolean") s.gift.introSeen=false;
    s.gift.shareUrl = String(s.gift.shareUrl||"");

    if(!s.game || typeof s.game!=="object") s.game = {...d.game};
    s.game.snakeHighScore = toInt(s.game.snakeHighScore, 0);
    s.game.snakeLastDailyDone = s.game.snakeLastDailyDone ? String(s.game.snakeLastDailyDone) : null;
    s.game.snakeDailyEnabled = (s.game.snakeDailyEnabled!==false);
    s.game.snakePendingDaily = !!s.game.snakePendingDaily;
    s.game.snakeWrap = !!s.game.snakeWrap;
    s.game.snakeRamp = (s.game.snakeRamp !== false);

    s.stats.done = toInt(s.stats.done,0);
    s.stats.boss = toInt(s.stats.boss,0);
    s.stats.focusDone = toInt(s.stats.focusDone,0);
    s.stats.xmasDone = toInt(s.stats.xmasDone,0);

    return s;
  }

  function load(){
    try{
      const raw = JSON.parse(localStorage.getItem(KEY));
      return normalizeState(raw || defaultState());
    } catch {
      return normalizeState(defaultState());
    }
  }
  function save(s){ localStorage.setItem(KEY, JSON.stringify(s)); }

  function updateStreak(s){
    const t=todayISO();
    if(!s.lastDay){ s.streak=1; s.lastDay=t; return; }
    if(s.lastDay===t) return;
    s.streak = (s.lastDay===yesterdayISO()) ? (s.streak+1) : 1;
    s.lastDay=t;
  }

  function unlock(s,id){
    if(s.ach[id]) return;
    s.ach[id]=true;
    alert("Achievement freigeschaltet: " + ACH_LABELS[id]);
  }

  function checkAchievements(s){
    if(s.stats.done>=1) unlock(s,"firstQuest");
    if(s.stats.done>=10) unlock(s,"quest10");
    if(s.stats.boss>=1) unlock(s,"boss1");
    if(s.streak>=3) unlock(s,"streak3");
    if(s.level>=5) unlock(s,"lvl5");
    if(s.stats.focusDone>=1) unlock(s,"focus1");

    if(s.stats.xmasDone>=1) unlock(s,"xmasMulled");
    if(s.stats.xmasDone>=3) unlock(s,"xmasRaid");
    if(s.stats.xmasDone>=5) unlock(s,"winterGrind");

    if((s.game?.snakeHighScore||0) >= 5) unlock(s,"snake5");
    if((s.game?.snakeHighScore||0) >= 20) unlock(s,"snake20");
  }

  function gainRewards(s, xpGain, coinGain, note){
    updateStreak(s);
    s.xp += xpGain;
    s.coins += coinGain;

    while(s.xp >= xpForNext(s.level)){
      s.xp -= xpForNext(s.level);
      s.level += 1;
      s.log.unshift(`${todayISO()} ‚Äî Levelaufstieg ‚Üí ${s.level}`);
    }
    s.log.unshift(`${todayISO()} ‚Äî +${xpGain} XP, +${coinGain} Coins ‚Äî ${note}`);
    checkAchievements(s);
  }

  // --- Quest pools (Deutsch) ---
  const DAILY_POOL = [
    {title:"Aufw√§rm-Quest", desc:"10 Min Mobility/Dehnen", xp:25, coins:5, tag:"Fitness"},
    {title:"Nebenquest: Schritte", desc:"20 Min Spaziergang", xp:30, coins:5, tag:"Fitness"},
    {title:"Raid-Vorbereitung", desc:"Flasche f√ºllen + 1L Wasser", xp:15, coins:4, tag:"Fitness"},
    {title:"Fokus-Sprint", desc:"15 Min ohne Handy (Studium/Arbeit)", xp:35, coins:8, tag:"Lernen"},
    {title:"Inventar aufr√§umen", desc:"Schreibtisch 5 Min aufr√§umen", xp:18, coins:4, tag:"Ordnung"},
    {title:"Gl√ºhwein-Quest", desc:"Mach dir ein Heissgetr√§nk & g√∂nn dir 10 Min Pause.", xp:25, coins:8, tag:"Weihnachten"},
    {title:"Pl√§tzchen-Run", desc:"Snack vorbereiten (oder 1 St√ºck bewusst geniessen).", xp:20, coins:6, tag:"Weihnachten"},
    {title:"Geschenk-Check", desc:"Schick einer Person eine kurze Nachricht.", xp:22, coins:6, tag:"Weihnachten"},
  ];

  const WEEKLY_POOL = [
    {title:"Dungeon-Run", desc:"3 Trainings diese Woche", xp:120, coins:30, tag:"Fitness"},
    {title:"Boss-Route", desc:"1 langer Fokusblock (60 Min)", xp:100, coins:25, tag:"Lernen"},
    {title:"Co-op-Quest", desc:"Gemeinsam etwas planen (Walk, Game, Kaffee).", xp:70, coins:20, tag:"Sozial"},
    {title:"Family Raid", desc:"1 Familien-/Freunde-Aktion planen oder durchziehen.", xp:110, coins:28, tag:"Weihnachten"}
  ];

  const BOSSFIGHTS = [
    {title:"Bosskampf: PR-Versuch", desc:"PR-Versuch oder schwerer Satz", xp:160, coins:40, tag:"Fitness", boss:true},
    {title:"Bosskampf: Ranked-Disziplin", desc:"Nur 2 Games + Review (kein Tilt)", xp:130, coins:35, tag:"Gaming", boss:true},
    {title:"Bosskampf: Fest-Modus", desc:"Familien-Event: freundlich bleiben & 1 gutes Gespr√§ch f√ºhren.", xp:150, coins:45, tag:"Weihnachten", boss:true}
  ];

  function pickUnique(pool, n){
    const copy=[...pool];
    const out=[];
    while(out.length<n && copy.length){
      out.push(copy.splice(Math.floor(Math.random()*copy.length),1)[0]);
    }
    return out;
  }

  function combinedPool(s, type){
    const builtIn =
      type==="daily" ? DAILY_POOL :
      type==="weekly" ? WEEKLY_POOL :
      type==="boss" ? BOSSFIGHTS : [];
    const custom = (s.customQuests||[]).filter(q=>q.type===type && q.enabled!==false);
    return [...builtIn, ...custom];
  }

  function ensureSnakeDailyQuest(s){
    if(!s?.gift?.snakeDailyQuest) return;
    const id = "snakeDaily-" + todayISO();
    const already = (s.quests||[]).some(q=>q.id===id);
    if(already) return;
    const doneToday = (s.game?.snakeLastDailyDone === todayISO());
    const q = {
      id,
      title:"Daily: Snake-Run",
      desc:"Spiele 1 Runde Snake (mind. 5 Punkte). Belohnung nach Game Over (1√ó pro Tag).",
      xp:25, coins:8, tag:"Retro", done:doneToday,
      special:"snakeDaily"
    };
    s.quests = [q, ...(s.quests||[])];
  }

  function makeDailies(s){
    const poolDaily = combinedPool(s, "daily");
    const base = pickUnique(poolDaily, 4);
    const bossChance = 0.25;
    const poolBoss = combinedPool(s, "boss");
    const maybeBoss = (poolBoss.length && Math.random()<bossChance) ? pickUnique(poolBoss,1) : [];
    s.quests = [...base, ...maybeBoss].map((q,i)=>({
      id: crypto.randomUUID?.() || String(Date.now()+i),
      ...q,
      done:false
    }));
    ensureSnakeDailyQuest(s);
  }

  function makeWeeklies(s){
    const poolWeekly = combinedPool(s, "weekly");
    s.quests = pickUnique(poolWeekly, 4).map((q,i)=>({
      id: crypto.randomUUID?.() || String(Date.now()+i),
      ...q,
      done:false,
      weekly:true
    }));
  }

  // --- Custom quests management ---
  let editingCustomId = null;
  function clearCustomForm(){
    editingCustomId = null;
    el("cqTitle").value = "";
    el("cqDesc").value = "";
    el("cqTag").value = "";
    el("cqType").value = "daily";
    el("cqXP").value = "30";
    el("cqCoins").value = "5";
    el("cqAdd").textContent = "Ôºã Hinzuf√ºgen";
    el("cqCancel").style.display = "none";
  }

  function upsertCustomQuest(){
    const s = load();
    const title = (el("cqTitle").value || "").trim();
    if(!title){ alert("Bitte gib mindestens einen Titel an."); return; }
    const q = {
      id: editingCustomId || (crypto.randomUUID?.() || String(Date.now())),
      title,
      desc: (el("cqDesc").value || "").trim(),
      tag: (el("cqTag").value || "Ohne Tag").trim(),
      type: el("cqType").value,
      xp: Math.max(0, toInt(el("cqXP").value, 0)),
      coins: Math.max(0, toInt(el("cqCoins").value, 0)),
      boss: el("cqType").value==="boss" ? true : false,
      enabled: true
    };

    s.customQuests = s.customQuests || [];
    const idx = s.customQuests.findIndex(x=>x.id===q.id);
    if(idx>=0) s.customQuests[idx] = {...s.customQuests[idx], ...q};
    else s.customQuests.unshift(q);

    save(s);
    clearCustomForm();
    render();
  }

  function renderCustomQuests(s){
    const root = el("customQuestList");
    root.innerHTML = "";
    const list = (s.customQuests||[]);
    if(list.length===0){
      const msg=document.createElement("div");
      msg.className="muted";
      msg.textContent="Noch keine eigenen Quests. Erstelle oben deine erste.";
      root.appendChild(msg);
      return;
    }

    list.forEach(q=>{
      const div=document.createElement("div");
      div.className="q";

      const left=document.createElement("div");

      const titleRow=document.createElement("div");
      const title=document.createElement("span");
      title.className="qtitle";
      title.textContent=q.title;

      const pills=document.createElement("span");
      const pTag=document.createElement("span"); pTag.className="pill"; pTag.textContent=q.tag || "Ohne Tag";
      const pType=document.createElement("span"); pType.className="pill"; pType.textContent = q.type==="daily"?"Daily":q.type==="weekly"?"Weekly":"Boss";
      pills.append(pTag, pType);

      if(q.enabled===false){
        const p=document.createElement("span"); p.className="pill"; p.textContent="Deaktiviert"; pills.appendChild(p);
      }

      titleRow.append(title, document.createTextNode(" "), pills);

      const desc=document.createElement("div");
      desc.className="qdesc";
      desc.textContent=q.desc || "";

      const meta=document.createElement("div");
      meta.className="qmeta";
      meta.textContent=`+${q.xp} XP, +${q.coins} Coins`;

      left.appendChild(titleRow);
      if(q.desc) left.appendChild(desc);
      left.appendChild(meta);

      const right=document.createElement("div");
      right.className="row";

      const edit=document.createElement("button");
      edit.textContent="Bearbeiten";
      edit.type="button";
      edit.addEventListener("click", ()=>{
        editingCustomId = q.id;
        el("cqTitle").value = q.title || "";
        el("cqDesc").value = q.desc || "";
        el("cqTag").value = q.tag || "";
        el("cqType").value = q.type || "daily";
        el("cqXP").value = String(q.xp ?? 0);
        el("cqCoins").value = String(q.coins ?? 0);
        el("cqAdd").textContent = "üíæ Speichern";
        el("cqCancel").style.display = "";
        setTab("quests");
        window.scrollTo({top:0, behavior:"smooth"});
      });

      const toggle=document.createElement("button");
      toggle.type="button";
      toggle.textContent = (q.enabled===false) ? "Aktivieren" : "Deaktivieren";
      toggle.addEventListener("click", ()=>{
        const s2=load();
        const item = (s2.customQuests||[]).find(x=>x.id===q.id);
        if(!item) return;
        item.enabled = (item.enabled===false) ? true : false;
        save(s2);
        render();
      });

      const del=document.createElement("button");
      del.className="danger";
      del.type="button";
      del.textContent="L√∂schen";
      del.addEventListener("click", ()=>{
        if(!confirm("Diese eigene Quest wirklich l√∂schen?")) return;
        const s2=load();
        s2.customQuests = (s2.customQuests||[]).filter(x=>x.id!==q.id);
        save(s2);
        if(editingCustomId===q.id) clearCustomForm();
        render();
      });

      right.append(edit, toggle, del);

      div.append(left, right);
      root.appendChild(div);
    });
  }

  // --- Rendering ---
  function applyTheme(s){
    document.body.classList.remove("xmas","retro","classic");
    if(s.gift.theme==="xmas") document.body.classList.add("xmas");
    if(s.gift.theme==="retro") document.body.classList.add("retro");
    if(s.gift.theme==="classic") document.body.classList.add("classic");
    if(s.gift.pixel) document.body.classList.add("pixel");
    else document.body.classList.remove("pixel");
  }

  function renderGiftHeader(s){
    const name = (s.gift.recipientName||"").trim();
    el("appTitle").textContent = name ? `Reto's personal Game ‚Äî ${name}` : "Reto's personal Game";
    el("appSubtitle").textContent = "Deine Quests werden lokal auf deinem Ger√§t gespeichert (kein Account, kein Server).";
  }

  function openGiftModal(s){
    const name = (s.gift.recipientName || "").trim();
    el("giftModalTitle").textContent = name ? `üéÅ F√ºr ${name}` : "üéÅ Start";
    const msg = (s.gift.message || "").trim();
    el("giftModalText").textContent = msg ? msg : defaultGiftMessage();

    const story = (s.gift.story || "").trim() || defaultStoryTemplate(name);
    el("giftModalStory").textContent = story;

    el("giftModalBack").classList.remove("hidden");
  }
  function closeGiftModal(){ el("giftModalBack").classList.add("hidden"); }

  function renderStory(s){
    const name = (s.gift.recipientName||"").trim();
    const story = (s.gift.story || "").trim() || defaultStoryTemplate(name);
    el("storyPreview").textContent = story;
    el("giftStory").value = (s.gift.story || "").trim() || story;
  }

  function renderGiftCard(s){
    el("giftName").value = s.gift.recipientName || "";
    el("giftMsg").value = s.gift.message || "";
    el("giftTheme").value = s.gift.theme || "xmas";
    el("giftPixel").checked = !!s.gift.pixel;
    el("giftSnakeDaily").checked = !!s.gift.snakeDailyQuest;

    const url = (s.gift.shareUrl||"").trim() || guessDefaultUrl();
    el("qrUrl").value = url;
    renderGiftPrint(s, url);
    drawQRToCanvas(url, el("qrCanvas"));
  }

  function renderGiftPrint(s, url){
    const name = (s.gift.recipientName||"").trim();
    el("cardTitle").textContent = name ? `F√ºr ${name}` : "F√ºr dich";
    el("cardMsg").textContent = (s.gift.message||"").trim().replace(/\n/g, " ");
    el("cardUrl").textContent = url || "";
  }

  function renderSnakeHeader(s){
    el("snakeHighPill").textContent = `Highscore: ${s.game.snakeHighScore||0}`;
    const dailyDone = (s.game.snakeLastDailyDone === todayISO());
    el("snakeDailyPill").textContent = dailyDone ? "Daily: erledigt ‚úÖ" : "Daily: bereit";
    el("snakeDailyQuestToggle").checked = s.game.snakeDailyEnabled!==false;

    el("snakeWrapToggle").checked = !!s.game.snakeWrap;
    el("snakeRampToggle").checked = (s.game.snakeRamp !== false);
    snake.wrap = !!s.game.snakeWrap;
    snake.ramp = (s.game.snakeRamp !== false);
  }

  function renderXmasHint(s){
    const root = el("xmasAchHint");
    const lines = [
      "üéÑ Gl√ºhwein-Quest: schalte frei, indem du Weihnachts-Quests erledigst.",
      "üéÑ Family Raid: nach mehreren Weihnachts-Quests.",
      "üéÑ Wintergrind: 5 Weihnachts-Quests insgesamt.",
      "üêç Snake: 5 / 20 Punkte & Highscore-Bonus."
    ];
    root.innerHTML = lines.map(t=>`<span class="pill">${t}</span>`).join("");
  }

  function render(){
    const s = load();
    applyTheme(s);
    renderGiftHeader(s);
    setTab(s.ui.tab || "quests", {silent:true});

    if(!s.gift.introSeen){
      openGiftModal(s);
    }

    el("level").textContent=String(s.level);
    el("xp").textContent=String(s.xp);
    el("xpNext").textContent=String(xpForNext(s.level));
    el("coins").textContent=String(s.coins);
    el("streak").textContent=String(s.streak);

    // quests
    const questListEl = el("questList");
    questListEl.innerHTML="";
    if((s.quests||[]).length===0){
      const msg=document.createElement("div");
      msg.className="muted";
      msg.textContent='Noch keine Quests. Klicke auf ‚ÄûDaily Quests‚Äú.';
      questListEl.appendChild(msg);
    } else {
      s.quests.forEach(q=>{
        const div=document.createElement("div");
        div.className="q";

        const left=document.createElement("div");

        const titleRow=document.createElement("div");
        const title=document.createElement("span");
        title.className="qtitle";
        title.textContent=q.title;

        const pills=document.createElement("span");
        const pillTag=document.createElement("span");
        pillTag.className="pill";
        pillTag.textContent=q.tag || "Ohne Tag";
        pills.appendChild(pillTag);

        if(q.weekly){ const p=document.createElement("span"); p.className="pill"; p.textContent="Weekly"; pills.appendChild(p); }
        if(q.boss){ const p=document.createElement("span"); p.className="pill"; p.textContent="Boss"; pills.appendChild(p); }
        if(q.special==="snakeDaily"){ const p=document.createElement("span"); p.className="pill"; p.textContent="Daily"; pills.appendChild(p); }

        titleRow.appendChild(title);
        titleRow.appendChild(document.createTextNode(" "));
        titleRow.appendChild(pills);

        const desc=document.createElement("div");
        desc.className="qdesc";
        desc.textContent=q.desc || "";

        const meta=document.createElement("div");
        meta.className="qmeta";
        meta.textContent=`Reward: +${q.xp} XP, +${q.coins} Coins`;

        left.appendChild(titleRow);
        if(q.desc) left.appendChild(desc);
        left.appendChild(meta);

        const right=document.createElement("div");
        right.className="row";
        const btn=document.createElement("button");
        btn.type="button";
        btn.dataset.id=q.id;
        btn.disabled=!!q.done;
        btn.textContent = q.done ? "‚úÖ Erledigt" : (q.special==="snakeDaily" ? "Spielen" : "Abschlie√üen");
        right.appendChild(btn);

        div.appendChild(left);
        div.appendChild(right);
        questListEl.appendChild(div);
      });

      questListEl.querySelectorAll("button[data-id]").forEach(btn=>{
        btn.addEventListener("click", ()=>{
          const s2=load();
          const id=btn.getAttribute("data-id");
          const q=s2.quests.find(x=>x.id===id);
          if(!q || q.done) return;

          if(q.special==="snakeDaily"){
            s2.game.snakePendingDaily = true;
            save(s2);
            setTab("game");
            el("snakeMsg").textContent = "Daily aktiv: Spiele jetzt eine Runde (mind. 5 Punkte), dann bekommst du die Belohnung.";
            return;
          }

          q.done=true;
          s2.stats.done += 1;
          if(q.boss) s2.stats.boss += 1;
          if(String(q.tag||"").toLowerCase()==="weihnachten") s2.stats.xmasDone += 1;

          gainRewards(s2, q.xp, q.coins, `Quest abgeschlossen: ${q.title}`);
          save(s2);
          render();
        });
      });
    }

    renderCustomQuests(s);

    el("ach").innerHTML = Object.keys(ACH_LABELS).map(id=>{
      const got = !!s.ach[id];
      const pill = document.createElement("span");
      pill.className="pill";
      pill.title = got ? "Freigeschaltet" : "Gesperrt";
      pill.textContent = `${got?'‚úÖ':'üîí'} ${ACH_LABELS[id]}`;
      return pill.outerHTML;
    }).join("");

    const logEl = el("log");
    logEl.innerHTML="";
    (s.log||[]).slice(0,12).forEach(line=>{
      const li=document.createElement("li");
      li.textContent=line;
      logEl.appendChild(li);
    });

    renderStory(s);
    renderGiftCard(s);
    renderSnakeHeader(s);
    renderXmasHint(s);

    el("snakeScorePill").textContent = `Score: ${snake.score}`;
  }

  // --- Tabs ---
  function setTab(tab, opts={}){
    const tabs = ["quests","story","game","card"];
    tabs.forEach(t=>{
      const btn = document.querySelector(`.tabs button[data-tab="${t}"]`);
      const panel = el(`tab-${t}`);
      if(btn) btn.classList.toggle("active", t===tab);
      if(panel) panel.classList.toggle("hidden", t!==tab);
    });

    if(!opts.silent){
      const s=load();
      s.ui.tab = tab;
      save(s);
    }
  }

  // --- Focus timer ---
  let timer=null, remaining=0;
  function fmt(sec){
    const m=String(Math.floor(sec/60)).padStart(2,"0");
    const s=String(sec%60).padStart(2,"0");
    return `${m}:${s}`;
  }
  function startTimer(){
    const s=load();
    if(timer){
      clearInterval(timer); timer=null; remaining=0;
      el("timerBtn").textContent="‚ñ∂ Fokus 15:00";
      el("timerTxt").textContent="00:00";
      return;
    }
    remaining=15*60;
    el("timerBtn").textContent="‚è∏ Stop";
    el("timerTxt").textContent=fmt(remaining);
    timer=setInterval(()=>{
      remaining--;
      el("timerTxt").textContent=fmt(Math.max(0,remaining));
      if(remaining<=0){
        clearInterval(timer); timer=null;
        el("timerBtn").textContent="‚ñ∂ Fokus 15:00";
        s.stats.focusDone += 1;
        gainRewards(s, 40, 10, "Fokus-Timer abgeschlossen");
        save(s);
        render();
        alert("Fokus abgeschlossen! +40 XP, +10 Coins");
      }
    }, 1000);
  }

  // --- Events ---
  document.querySelectorAll(".tabs button[data-tab]").forEach(b=>{
    b.addEventListener("click", ()=> setTab(b.getAttribute("data-tab")));
  });

  el("newDaily").addEventListener("click", ()=>{ const s=load(); makeDailies(s); save(s); render(); });
  el("newWeekly").addEventListener("click", ()=>{ const s=load(); makeWeeklies(s); save(s); render(); });
  el("timerBtn").addEventListener("click", startTimer);
  el("reset").addEventListener("click", ()=>{
    if(confirm("Wirklich alles l√∂schen?")){ localStorage.removeItem(KEY); render(); }
  });

  el("cqAdd").addEventListener("click", upsertCustomQuest);
  el("cqCancel").addEventListener("click", clearCustomForm);

  el("exportBtn").addEventListener("click", async ()=>{
    const s=load();
    const payload = JSON.stringify({version:2, customQuests:(s.customQuests||[])}, null, 2);
    try{
      await navigator.clipboard.writeText(payload);
      alert("Export kopiert (JSON).");
    } catch {
      prompt("Kopiere den Export-JSON:", payload);
    }
  });

  el("importBtn").addEventListener("click", ()=>{
    const txt = prompt("F√ºge hier den Export-JSON ein:");
    if(!txt) return;
    try{
      const data = JSON.parse(txt);
      const list = Array.isArray(data?.customQuests) ? data.customQuests : Array.isArray(data) ? data : null;
      if(!list) throw new Error("Ung√ºltiges Format");
      const s=load();
      s.customQuests = list.map(q=>({
        id: q.id || (crypto.randomUUID?.() || String(Date.now()+Math.random())),
        title: String(q.title||"").trim(),
        desc: String(q.desc||"").trim(),
        tag: String(q.tag||"Ohne Tag").trim(),
        type: (q.type==="weekly"||q.type==="boss") ? q.type : "daily",
        xp: Math.max(0, toInt(q.xp, 0)),
        coins: Math.max(0, toInt(q.coins, 0)),
        boss: (q.type==="boss") ? true : !!q.boss,
        enabled: q.enabled!==false
      })).filter(q=>q.title);
      save(s);
      clearCustomForm();
      render();
      alert("Import erfolgreich.");
    } catch(e){
      alert("Import fehlgeschlagen: " + (e?.message||"Unbekannter Fehler"));
    }
  });

  // Gift settings
  el("giftSave").addEventListener("click", ()=>{
    const s = load();
    s.gift.recipientName = (el("giftName").value || "").trim() || "Reto";
    s.gift.message = (el("giftMsg").value || "").trim() || defaultGiftMessage();
    s.gift.theme = (el("giftTheme").value || "xmas");
    s.gift.pixel = !!el("giftPixel").checked;
    s.gift.snakeDailyQuest = !!el("giftSnakeDaily").checked;

    if(!s.gift.story) s.gift.story = defaultStoryTemplate(s.gift.recipientName);

    save(s);
    render();
    alert("Geschenkmodus gespeichert.");
  });

  el("giftPreview").addEventListener("click", ()=>{ openGiftModal(load()); });

  el("giftClose").addEventListener("click", closeGiftModal);
  el("giftModalBack").addEventListener("click", (e)=>{ if(e.target===el("giftModalBack")) closeGiftModal(); });

  el("giftStart").addEventListener("click", ()=>{
    const s=load();
    s.gift.introSeen=true;
    save(s);
    closeGiftModal();
    render();
  });

  // Story editing
  el("storySave").addEventListener("click", ()=>{
    const s=load();
    s.gift.story = (el("giftStory").value || "").trim();
    save(s);
    render();
    alert("Story gespeichert.");
  });
  el("storyReset").addEventListener("click", ()=>{
    const s=load();
    s.gift.story = defaultStoryTemplate((s.gift.recipientName||"").trim());
    save(s);
    render();
  });
  el("storyShow").addEventListener("click", ()=> openGiftModal(load()));

  // QR / print
  el("qrGen").addEventListener("click", ()=>{
    const s=load();
    const url = (el("qrUrl").value||"").trim();
    s.gift.shareUrl = url;
    save(s);
    renderGiftPrint(s, url);
    drawQRToCanvas(url, el("qrCanvas"));
    alert("QR-Code aktualisiert.");
  });
  el("printBtn").addEventListener("click", ()=> window.print());

  // Snake daily toggle
  el("snakeDailyQuestToggle").addEventListener("change", ()=>{
    const s=load();
    s.game.snakeDailyEnabled = !!el("snakeDailyQuestToggle").checked;
    save(s);
    render();
  });

  // Wrap + Speed Ramp toggles
  el("snakeWrapToggle").addEventListener("change", ()=>{
    const s=load();
    s.game.snakeWrap = !!el("snakeWrapToggle").checked;
    save(s);
    snake.wrap = s.game.snakeWrap;
  });

  el("snakeRampToggle").addEventListener("change", ()=>{
    const s=load();
    s.game.snakeRamp = !!el("snakeRampToggle").checked;
    save(s);
    snake.ramp = s.game.snakeRamp;
    if(snake.running){
      stopSnakeLoop();
      startSnakeLoop();
    }
  });

  // --- QR Code generator (minimal) ---
  function drawQRToCanvas(text, canvas){
    const ctx = canvas.getContext("2d");
    ctx.clearRect(0,0,canvas.width,canvas.height);
    if(!text){
      ctx.fillStyle="#111";
      ctx.font="12px system-ui, Arial";
      ctx.fillText("Kein Link", 10, 20);
      return;
    }

    let qr=null;
    try{
      qr = QRCodeModel(0, QRErrorCorrectLevel.M);
      qr.addData(text);
      qr.make();
    } catch(e){
      ctx.fillStyle="#fff"; ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle="#111"; ctx.font="12px system-ui, Arial";
      const msg = String(e?.message||"QR Fehler");
      ctx.fillText("QR Fehler:", 10, 22);
      ctx.fillText(msg.slice(0,36), 10, 40);
      ctx.fillText("Tipp: Link k√ºrzen.", 10, 58);
      return;
    }

    const moduleCount = qr.getModuleCount();
    const size = Math.floor(Math.min(canvas.width, canvas.height));
    const cell = Math.floor(size / (moduleCount + 8));
    const offset = Math.floor((size - cell * moduleCount) / 2);

    ctx.fillStyle = "#fff";
    ctx.fillRect(0,0,size,size);

    ctx.fillStyle = "#111";
    for(let r=0;r<moduleCount;r++){
      for(let c=0;c<moduleCount;c++){
        if(qr.isDark(r,c)){
          ctx.fillRect(offset + c*cell, offset + r*cell, cell, cell);
        }
      }
    }
  }

  function guessDefaultUrl(){
    try{
      const href = String(location.href||"");
      if(href.startsWith("http://") || href.startsWith("https://")) return href;
    } catch {}
    return "";
  }

  // --- Snake game implementation ---
  const snake = {
    grid: 20,
    cell: 16,
    dir: {x:1,y:0},
    nextDir: {x:1,y:0},
    body: [{x:10,y:10},{x:9,y:10},{x:8,y:10}],
    food: {x:14,y:10},
    score: 0,
    running: false,
    paused: false,
    loop: null,

    speed: 5,       // base speed (dropdown)
    wrap: false,    // walls off
    ramp: true      // speed increases with score
  };

  function randFood(){
    const occ = new Set(snake.body.map(p=>`${p.x},${p.y}`));
    let x,y;
    do{
      x = Math.floor(Math.random()*snake.grid);
      y = Math.floor(Math.random()*snake.grid);
    } while(occ.has(`${x},${y}`));
    snake.food = {x,y};
  }

  function resetRun(){
    snake.dir = {x:1,y:0};
    snake.nextDir = {x:1,y:0};
    snake.body = [{x:10,y:10},{x:9,y:10},{x:8,y:10}];
    snake.score = 0;
    randFood();
    snake.paused = false;
    drawSnake();
    el("snakeScorePill").textContent = `Score: ${snake.score}`;
    el("snakeMsg").textContent = "";
  }

  function setSpeed(){
    snake.speed = toInt(el("snakeSpeed").value, 5);
    if(snake.running){
      stopSnakeLoop();
      startSnakeLoop();
    }
  }

  function startSnakeLoop(){
    const base = snake.speed || 5;
    const extra = (snake.ramp ? Math.min(6, Math.floor(snake.score / 6)) : 0);
    const effectiveSpeed = base + extra;

    const interval = Math.max(65, Math.floor(1600 / effectiveSpeed));
    snake.loop = setInterval(stepSnake, interval);
  }

  function stopSnakeLoop(){
    if(snake.loop){ clearInterval(snake.loop); snake.loop=null; }
  }

  function startSnake(){
    if(snake.running) return;
    setSpeed();
    snake.running = true;
    snake.paused = false;
    startSnakeLoop();
    el("snakeMsg").textContent = "Viel Erfolg! üêç";
  }

  function pauseSnake(){
    if(!snake.running) return;
    snake.paused = !snake.paused;
    el("snakeMsg").textContent = snake.paused ? "Pause." : "Weiter!";
  }

  function gameOver(){
    stopSnakeLoop();
    snake.running=false;
    snake.paused=false;
    const score = snake.score;
    el("snakeMsg").textContent = `Game Over. Score: ${score}`;
    handleSnakeRunComplete(score);
  }

  function stepSnake(){
    if(!snake.running || snake.paused) return;

    const nd = snake.nextDir;
    if(!(nd.x === -snake.dir.x && nd.y === -snake.dir.y)){
      snake.dir = {...nd};
    }

    const head = snake.body[0];
    const nh = {x: head.x + snake.dir.x, y: head.y + snake.dir.y};

    // Walls vs Wrap-around
    if(snake.wrap){
      if(nh.x < 0) nh.x = snake.grid - 1;
      if(nh.x >= snake.grid) nh.x = 0;
      if(nh.y < 0) nh.y = snake.grid - 1;
      if(nh.y >= snake.grid) nh.y = 0;
    } else {
      if(nh.x<0 || nh.y<0 || nh.x>=snake.grid || nh.y>=snake.grid){
        return gameOver();
      }
    }

    if(snake.body.some(p=>p.x===nh.x && p.y===nh.y)){
      return gameOver();
    }

    snake.body.unshift(nh);

    if(nh.x===snake.food.x && nh.y===snake.food.y){
      snake.score += 1;
      randFood();

      // apply ramp immediately
      if(snake.running){
        stopSnakeLoop();
        startSnakeLoop();
      }
    } else {
      snake.body.pop();
    }

    el("snakeScorePill").textContent = `Score: ${snake.score}`;
    drawSnake();
  }

  function drawSnake(){
    const canvas = el("snakeCanvas");
    const ctx = canvas.getContext("2d");
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = "#fff";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    ctx.strokeStyle = "rgba(0,0,0,.06)";
    for(let i=0;i<=snake.grid;i++){
      ctx.beginPath(); ctx.moveTo(i*snake.cell,0); ctx.lineTo(i*snake.cell,canvas.height); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0,i*snake.cell); ctx.lineTo(canvas.width,i*snake.cell); ctx.stroke();
    }

    ctx.fillStyle = "#111";
    ctx.fillRect(snake.food.x*snake.cell, snake.food.y*snake.cell, snake.cell, snake.cell);

    ctx.fillStyle = "rgba(0,0,0,.85)";
    snake.body.forEach((p, idx)=>{
      const pad = idx===0 ? 1 : 2;
      ctx.fillRect(p.x*snake.cell+pad, p.y*snake.cell+pad, snake.cell-2*pad, snake.cell-2*pad);
    });
  }

  function handleSnakeRunComplete(score){
    const s = load();

    const prevHS = s.game.snakeHighScore||0;
    if(score > prevHS){
      s.game.snakeHighScore = score;
      gainRewards(s, 60, 20, `Snake: Neuer Highscore (${score})`);
      unlock(s, "snakeHS");
    }

    if(score >= 5) unlock(s, "snake5");
    if(score >= 20) unlock(s, "snake20");

    const today = todayISO();
    const dailyAlreadyDone = (s.game.snakeLastDailyDone === today);
    const dailyEnabled = (s.game.snakeDailyEnabled!==false);

    if(s.game.snakePendingDaily && dailyEnabled && !dailyAlreadyDone){
      if(score >= 5){
        s.game.snakeLastDailyDone = today;
        s.game.snakePendingDaily = false;

        const qid = "snakeDaily-" + today;
        const q = (s.quests||[]).find(x=>x.id===qid);
        if(q){ q.done = true; }

        s.stats.done += 1;
        gainRewards(s, 25, 8, `Daily abgeschlossen: Snake-Run (${score} Punkte)`);
      } else {
        el("snakeMsg").textContent = `Daily noch nicht geschafft (mind. 5 Punkte). Versuche es erneut!`;
      }
    }

    save(s);
    render();
  }

  el("snakeClaim").addEventListener("click", ()=>{
    const s=load();
    if(s.game.snakeLastDailyDone === todayISO()){
      el("snakeMsg").textContent = "Daily ist heute schon erledigt ‚úÖ";
      return;
    }
    if(!s.game.snakePendingDaily){
      el("snakeMsg").textContent = "Tipp: Starte die Daily-Quest √ºber die Quest-Liste (‚ÄûDaily: Snake-Run‚Äú ‚Üí Spielen).";
    } else {
      el("snakeMsg").textContent = "Daily ist aktiv. Spiel eine Runde (mind. 5 Punkte) und beende sie.";
    }
  });

  el("snakeStart").addEventListener("click", ()=>{ setSpeed(); startSnake(); });
  el("snakePause").addEventListener("click", pauseSnake);
  el("snakeReset").addEventListener("click", ()=>{ stopSnakeLoop(); snake.running=false; resetRun(); });
  el("snakeSpeed").addEventListener("change", setSpeed);

  // Keyboard controls
  window.addEventListener("keydown", (e)=>{
    const k = e.key.toLowerCase();
    let d=null;
    if(k==="arrowup" || k==="w") d={x:0,y:-1};
    if(k==="arrowdown" || k==="s") d={x:0,y:1};
    if(k==="arrowleft" || k==="a") d={x:-1,y:0};
    if(k==="arrowright" || k==="d") d={x:1,y:0};
    if(d){
      snake.nextDir = d;
      e.preventDefault();
    }
  });

  // =========================
  // SNAKE: Resize + Touch + D-Pad
  // =========================
  function resizeSnakeCanvas(){
    const canvas = el("snakeCanvas");
    if(!canvas) return;

    const max = Math.min(Math.floor(window.innerWidth * 0.96), 520);
    const size = Math.max(320, max);

    canvas.width = size;
    canvas.height = size;

    snake.cell = Math.floor(size / snake.grid);
    drawSnake();
  }
  window.addEventListener("resize", resizeSnakeCanvas);

  (function setupSnakeTouch(){
    const canvas = el("snakeCanvas");
    if(!canvas) return;

    let startX=0, startY=0, startT=0;

    canvas.addEventListener("touchstart", (e)=>{
      const t = e.touches[0];
      startX = t.clientX; startY = t.clientY; startT = Date.now();
    }, {passive:true});

    canvas.addEventListener("touchmove", (e)=>{ e.preventDefault(); }, {passive:false});

    canvas.addEventListener("touchend", (e)=>{
      const dx = (e.changedTouches[0].clientX - startX);
      const dy = (e.changedTouches[0].clientY - startY);
      const dt = Date.now() - startT;

      if(dt > 700) return;
      if(Math.abs(dx) < 18 && Math.abs(dy) < 18) return;

      if(Math.abs(dx) > Math.abs(dy)){
        snake.nextDir = dx > 0 ? {x:1,y:0} : {x:-1,y:0};
      } else {
        snake.nextDir = dy > 0 ? {x:0,y:1} : {x:0,y:-1};
      }
    }, {passive:true});
  })();

  function bindBtn(id, dir){
    const b = el(id);
    if(!b) return;
    const handler = (e)=>{ e.preventDefault(); snake.nextDir = dir; };
    b.addEventListener("click", handler);
    b.addEventListener("touchstart", handler, {passive:false});
  }
  bindBtn("btnUp", {x:0,y:-1});
  bindBtn("btnDown", {x:0,y:1});
  bindBtn("btnLeft", {x:-1,y:0});
  bindBtn("btnRight", {x:1,y:0});

  const pauseBtn = el("btnPause");
  if(pauseBtn){
    pauseBtn.addEventListener("click", (e)=>{ e.preventDefault(); pauseSnake(); });
    pauseBtn.addEventListener("touchstart", (e)=>{ e.preventDefault(); pauseSnake(); }, {passive:false});
  }

  // --- QR generator (embedded, based on classic qrcode-generator approach) ---
  const QRErrorCorrectLevel = { L:1, M:0, Q:3, H:2 };

  function QRCodeModel(typeNumber, errorCorrectLevel) {
    let _typeNumber = typeNumber;
    let _errorCorrectLevel = errorCorrectLevel;
    let _modules = null;
    let _moduleCount = 0;
    let _dataCache = null;
    let _dataList = [];

    const PAD0 = 0xEC;
    const PAD1 = 0x11;

    function _makeImpl(test, maskPattern) {
      _moduleCount = _typeNumber * 4 + 17;
      _modules = new Array(_moduleCount);
      for (let row = 0; row < _moduleCount; row++) {
        _modules[row] = new Array(_moduleCount);
        for (let col = 0; col < _moduleCount; col++) {
          _modules[row][col] = null;
        }
      }

      _setupPositionProbePattern(0, 0);
      _setupPositionProbePattern(_moduleCount - 7, 0);
      _setupPositionProbePattern(0, _moduleCount - 7);
      _setupPositionAdjustPattern();
      _setupTimingPattern();
      _setupTypeInfo(test, maskPattern);

      if (_typeNumber >= 7) {
        _setupTypeNumber(test);
      }

      if (_dataCache == null) {
        _dataCache = _createData(_typeNumber, _errorCorrectLevel, _dataList);
      }

      _mapData(_dataCache, maskPattern);
    }

    function _setupPositionProbePattern(row, col) {
      for (let r = -1; r <= 7; r++) {
        if (row + r <= -1 || _moduleCount <= row + r) continue;
        for (let c = -1; c <= 7; c++) {
          if (col + c <= -1 || _moduleCount <= col + c) continue;
          if ((0 <= r && r <= 6 && (c == 0 || c == 6)) ||
              (0 <= c && c <= 6 && (r == 0 || r == 6)) ||
              (2 <= r && r <= 4 && 2 <= c && c <= 4)) {
            _modules[row + r][col + c] = true;
          } else {
            _modules[row + r][col + c] = false;
          }
        }
      }
    }

    function _getBestMaskPattern() {
      let minLostPoint = 0;
      let pattern = 0;
      for (let i = 0; i < 8; i++) {
        _makeImpl(true, i);
        let lostPoint = QRUtil.getLostPoint({getModuleCount:()=>_moduleCount,isDark:(r,c)=>_modules[r][c]});
        if (i == 0 || minLostPoint > lostPoint) {
          minLostPoint = lostPoint;
          pattern = i;
        }
      }
      return pattern;
    }

    function _setupTimingPattern() {
      for (let r = 8; r < _moduleCount - 8; r++) {
        if (_modules[r][6] != null) continue;
        _modules[r][6] = (r % 2 == 0);
      }
      for (let c = 8; c < _moduleCount - 8; c++) {
        if (_modules[6][c] != null) continue;
        _modules[6][c] = (c % 2 == 0);
      }
    }

    function _setupPositionAdjustPattern() {
      const pos = QRUtil.getPatternPosition(_typeNumber);
      for (let i = 0; i < pos.length; i++) {
        for (let j = 0; j < pos.length; j++) {
          const row = pos[i];
          const col = pos[j];
          if (_modules[row][col] != null) continue;
          for (let r = -2; r <= 2; r++) {
            for (let c = -2; c <= 2; c++) {
              if (r == -2 || r == 2 || c == -2 || c == 2 ||
                  (r == 0 && c == 0)) {
                _modules[row + r][col + c] = true;
              } else {
                _modules[row + r][col + c] = false;
              }
            }
          }
        }
      }
    }

    function _setupTypeNumber(test) {
      const bits = QRUtil.getBCHTypeNumber(_typeNumber);
      for (let i = 0; i < 18; i++) {
        const mod = (!test && ((bits >> i) & 1) == 1);
        _modules[Math.floor(i / 3)][i % 3 + _moduleCount - 8 - 3] = mod;
      }
      for (let i = 0; i < 18; i++) {
        const mod = (!test && ((bits >> i) & 1) == 1);
        _modules[i % 3 + _moduleCount - 8 - 3][Math.floor(i / 3)] = mod;
      }
    }

    function _setupTypeInfo(test, maskPattern) {
      const data = (_errorCorrectLevel << 3) | maskPattern;
      const bits = QRUtil.getBCHTypeInfo(data);

      for (let i = 0; i < 15; i++) {
        const mod = (!test && ((bits >> i) & 1) == 1);
        if (i < 6) _modules[i][8] = mod;
        else if (i < 8) _modules[i + 1][8] = mod;
        else _modules[_moduleCount - 15 + i][8] = mod;
      }

      for (let i = 0; i < 15; i++) {
        const mod = (!test && ((bits >> i) & 1) == 1);
        if (i < 8) _modules[8][_moduleCount - i - 1] = mod;
        else if (i < 9) _modules[8][15 - i - 1 + 1] = mod;
        else _modules[8][15 - i - 1] = mod;
      }

      _modules[_moduleCount - 8][8] = (!test);
    }

    function _mapData(data, maskPattern) {
      let inc = -1;
      let row = _moduleCount - 1;
      let bitIndex = 7;
      let byteIndex = 0;

      for (let col = _moduleCount - 1; col > 0; col -= 2) {
        if (col == 6) col--;
        while (true) {
          for (let c = 0; c < 2; c++) {
            if (_modules[row][col - c] == null) {
              let dark = false;
              if (byteIndex < data.length) {
                dark = (((data[byteIndex] >>> bitIndex) & 1) == 1);
              }
              const mask = QRUtil.getMask(maskPattern, row, col - c);
              if (mask) dark = !dark;
              _modules[row][col - c] = dark;
              bitIndex--;
              if (bitIndex == -1) {
                byteIndex++;
                bitIndex = 7;
              }
            }
          }
          row += inc;
          if (row < 0 || _moduleCount <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    }

    function _createData(typeNumber, errorCorrectLevel, dataList) {
      const rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectLevel);

      const buffer = new QRBitBuffer();
      for (let i = 0; i < dataList.length; i++) {
        const data = dataList[i];
        buffer.put(data.getMode(), 4);
        buffer.put(data.getLength(), QRUtil.getLengthInBits(data.getMode(), typeNumber));
        data.write(buffer);
      }

      let totalDataCount = 0;
      for (let i = 0; i < rsBlocks.length; i++) totalDataCount += rsBlocks[i].dataCount;

      if (buffer.getLengthInBits() > totalDataCount * 8) throw new Error("Code too long");

      if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) buffer.put(0, 4);

      while (buffer.getLengthInBits() % 8 != 0) buffer.putBit(false);

      while (true) {
        if (buffer.getLengthInBits() >= totalDataCount * 8) break;
        buffer.put(PAD0, 8);
        if (buffer.getLengthInBits() >= totalDataCount * 8) break;
        buffer.put(PAD1, 8);
      }

      return QRCodeModel.createBytes(buffer, rsBlocks);
    }

    return {
      addData : function(data) {
        const newData = new QR8BitByte(data);
        _dataList.push(newData);
        _dataCache = null;
      },
      isDark : function(row, col) {
        if (_modules[row][col] != null) return _modules[row][col];
        else return false;
      },
      getModuleCount : function() { return _moduleCount; },
      make : function() {
        if (_typeNumber < 1) {
          _typeNumber = 1;
          for (; _typeNumber <= 7; _typeNumber++) {
            const rsBlocks = QRRSBlock.getRSBlocks(_typeNumber, _errorCorrectLevel);
            let totalDataCount = 0;
            for (let i = 0; i < rsBlocks.length; i++) totalDataCount += rsBlocks[i].dataCount;
            const buffer = new QRBitBuffer();
            for (let i = 0; i < _dataList.length; i++) {
              const data = _dataList[i];
              buffer.put(data.getMode(), 4);
              buffer.put(data.getLength(), QRUtil.getLengthInBits(data.getMode(), _typeNumber));
              data.write(buffer);
            }
            if (buffer.getLengthInBits() <= totalDataCount * 8) break;
          }
        }
        _makeImpl(false, _getBestMaskPattern());
      }
    };
  }

  QRCodeModel.createBytes = function(buffer, rsBlocks) {
    let offset = 0;
    let maxDcCount = 0;
    let maxEcCount = 0;

    const dcdata = new Array(rsBlocks.length);
    const ecdata = new Array(rsBlocks.length);

    for (let r = 0; r < rsBlocks.length; r++) {
      const dcCount = rsBlocks[r].dataCount;
      const ecCount = rsBlocks[r].totalCount - dcCount;

      maxDcCount = Math.max(maxDcCount, dcCount);
      maxEcCount = Math.max(maxEcCount, ecCount);

      dcdata[r] = new Array(dcCount);
      for (let i = 0; i < dcdata[r].length; i++) dcdata[r][i] = 0xff & buffer.buffer[i + offset];
      offset += dcCount;

      const rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
      const rawPoly = new QRPolynomial(dcdata[r], rsPoly.getLength() - 1);
      const modPoly = rawPoly.mod(rsPoly);

      ecdata[r] = new Array(rsPoly.getLength() - 1);
      for (let i = 0; i < ecdata[r].length; i++) {
        const modIndex = i + modPoly.getLength() - ecdata[r].length;
        ecdata[r][i] = (modIndex >= 0) ? modPoly.get(modIndex) : 0;
      }
    }

    let totalCodeCount = 0;
    for (let i = 0; i < rsBlocks.length; i++) totalCodeCount += rsBlocks[i].totalCount;

    const data = new Array(totalCodeCount);
    let index = 0;

    for (let i = 0; i < maxDcCount; i++) {
      for (let r = 0; r < rsBlocks.length; r++) {
        if (i < dcdata[r].length) data[index++] = dcdata[r][i];
      }
    }

    for (let i = 0; i < maxEcCount; i++) {
      for (let r = 0; r < rsBlocks.length; r++) {
        if (i < ecdata[r].length) data[index++] = ecdata[r][i];
      }
    }

    return data;
  };

  function QRRSBlock(totalCount, dataCount) { this.totalCount = totalCount; this.dataCount = dataCount; }
  QRRSBlock.getRSBlocks = function(typeNumber, errorCorrectLevel) {
    const rsBlock = QRRSBlock.getRsBlockTable(typeNumber, errorCorrectLevel);
    if (typeof rsBlock == 'undefined') throw new Error("RS block undefined");
    const length = rsBlock.length / 3;
    const list = [];
    for (let i = 0; i < length; i++) {
      const count = rsBlock[i*3+0];
      const totalCount = rsBlock[i*3+1];
      const dataCount = rsBlock[i*3+2];
      for (let j = 0; j < count; j++) list.push(new QRRSBlock(totalCount, dataCount));
    }
    return list;
  };
  QRRSBlock.getRsBlockTable = function(typeNumber, errorCorrectLevel) {
    const T = {
      1: [1,26,16],
      2: [1,44,28],
      3: [1,70,44],
      4: [1,100,64],
      5: [1,134,86],
      6: [2,86,54],
      7: [2,98,62]
    };
    if(!T[typeNumber]) throw new Error("Link zu lang f√ºr Offline-QR (bitte URL k√ºrzen)");
    return T[typeNumber];
  };

  const QRMode = { MODE_8BIT_BYTE: 1<<2 };

  function QR8BitByte(data) {
    this.mode = QRMode.MODE_8BIT_BYTE;
    this.data = data;
    this.getMode = ()=> this.mode;
    this.getLength = ()=> this.data.length;
    this.write = (buffer)=>{
      for (let i = 0; i < this.data.length; i++) buffer.put(this.data.charCodeAt(i), 8);
    };
  }

  function QRBitBuffer() {
    this.buffer = [];
    this.length = 0;
    this.get = (index)=>{
      const bufIndex = Math.floor(index / 8);
      return ((this.buffer[bufIndex] >>> (7 - index % 8)) & 1) == 1;
    };
    this.put = (num, length)=>{
      for (let i = 0; i < length; i++) this.putBit(((num >>> (length - i - 1)) & 1) == 1);
    };
    this.getLengthInBits = ()=> this.length;
    this.putBit = (bit)=>{
      const bufIndex = Math.floor(this.length / 8);
      if (this.buffer.length <= bufIndex) this.buffer.push(0);
      if (bit) this.buffer[bufIndex] |= (0x80 >>> (this.length % 8));
      this.length++;
    };
  }

  function QRPolynomial(num, shift) {
    let offset = 0;
    while (offset < num.length && num[offset] == 0) offset++;
    this.num = new Array(num.length - offset + shift);
    for (let i = 0; i < num.length - offset; i++) this.num[i] = num[i + offset];
    this.get = (index)=> this.num[index];
    this.getLength = ()=> this.num.length;
    this.multiply = (e)=>{
      const num = new Array(this.getLength() + e.getLength() - 1).fill(0);
      for (let i = 0; i < this.getLength(); i++) {
        for (let j = 0; j < e.getLength(); j++) {
          num[i + j] ^= QRMath.gexp(QRMath.glog(this.get(i)) + QRMath.glog(e.get(j)));
        }
      }
      return new QRPolynomial(num, 0);
    };
    this.mod = (e)=>{
      if (this.getLength() - e.getLength() < 0) return this;
      const ratio = QRMath.glog(this.get(0)) - QRMath.glog(e.get(0));
      const num = this.num.slice();
      for (let i = 0; i < e.getLength(); i++) num[i] ^= QRMath.gexp(QRMath.glog(e.get(i)) + ratio);
      return new QRPolynomial(num, 0).mod(e);
    };
  }

  const QRMath = (function(){
    const EXP_TABLE = new Array(256);
    const LOG_TABLE = new Array(256);
    for (let i = 0; i < 8; i++) EXP_TABLE[i] = 1 << i;
    for (let i = 8; i < 256; i++) EXP_TABLE[i] = EXP_TABLE[i-4] ^ EXP_TABLE[i-5] ^ EXP_TABLE[i-6] ^ EXP_TABLE[i-8];
    for (let i = 0; i < 255; i++) LOG_TABLE[EXP_TABLE[i]] = i;
    return {
      glog: (n)=>{ if (n < 1) throw new Error("glog"); return LOG_TABLE[n]; },
      gexp: (n)=>{ while (n < 0) n += 255; while (n >= 256) n -= 255; return EXP_TABLE[n]; }
    };
  })();

  const QRUtil = {
    PATTERN_POSITION_TABLE: [
      [], [6,18],[6,22],[6,26],[6,30],[6,34],[6,22,38],[6,24,42],[6,26,46],[6,28,50]
    ],
    G15: (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0),
    G18: (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0),
    G15_MASK: (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1),
    getBCHTypeInfo: function(data) {
      let d = data << 10;
      while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15) >= 0) {
        d ^= (QRUtil.G15 << (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15)));
      }
      return ((data << 10) | d) ^ QRUtil.G15_MASK;
    },
    getBCHTypeNumber: function(data) {
      let d = data << 12;
      while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18) >= 0) {
        d ^= (QRUtil.G18 << (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18)));
      }
      return (data << 12) | d;
    },
    getBCHDigit: function(data) {
      let digit = 0;
      while (data != 0) { digit++; data >>>= 1; }
      return digit;
    },
    getPatternPosition: function(typeNumber) {
      return QRUtil.PATTERN_POSITION_TABLE[typeNumber] || QRUtil.PATTERN_POSITION_TABLE[9];
    },
    getMask: function(maskPattern, i, j) {
      switch (maskPattern) {
        case 0: return (i + j) % 2 == 0;
        case 1: return i % 2 == 0;
        case 2: return j % 3 == 0;
        case 3: return (i + j) % 3 == 0;
        case 4: return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 == 0;
        case 5: return (i * j) % 2 + (i * j) % 3 == 0;
        case 6: return ((i * j) % 2 + (i * j) % 3) % 2 == 0;
        case 7: return ((i * j) % 3 + (i + j) % 2) % 2 == 0;
        default: return false;
      }
    },
    getErrorCorrectPolynomial: function(errorCorrectLength) {
      let a = new QRPolynomial([1], 0);
      for (let i = 0; i < errorCorrectLength; i++) a = a.multiply(new QRPolynomial([1, QRMath.gexp(i)], 0));
      return a;
    },
    getLengthInBits: function(mode, type) {
      if (1 <= type && type < 10) return 8;
      return 16;
    },
    getLostPoint: function(qrCode) {
      const moduleCount = qrCode.getModuleCount();
      let lostPoint = 0;

      for (let row = 0; row < moduleCount; row++) {
        for (let col = 0; col < moduleCount; col++) {
          let sameCount = 0;
          const dark = qrCode.isDark(row, col);
          for (let r = -1; r <= 1; r++) {
            if (row + r < 0 || moduleCount <= row + r) continue;
            for (let c = -1; c <= 1; c++) {
              if (col + c < 0 || moduleCount <= col + c) continue;
              if (r == 0 && c == 0) continue;
              if (dark == qrCode.isDark(row + r, col + c)) sameCount++;
            }
          }
          if (sameCount > 5) lostPoint += (3 + sameCount - 5);
        }
      }

      for (let row = 0; row < moduleCount - 1; row++) {
        for (let col = 0; col < moduleCount - 1; col++) {
          let count = 0;
          if (qrCode.isDark(row, col)) count++;
          if (qrCode.isDark(row + 1, col)) count++;
          if (qrCode.isDark(row, col + 1)) count++;
          if (qrCode.isDark(row + 1, col + 1)) count++;
          if (count == 0 || count == 4) lostPoint += 3;
        }
      }
      return lostPoint;
    }
  };

  // --- Boot ---
  clearCustomForm();
  resetRun();
  resizeSnakeCanvas();
  drawQRToCanvas("", el("qrCanvas"));

  const s0 = load();
  if(!s0.gift.story) s0.gift.story = defaultStoryTemplate((s0.gift.recipientName||"").trim());
  if(!s0.gift.shareUrl) s0.gift.shareUrl = guessDefaultUrl();
  save(s0);

  render();
</script>
</body>
</html>
